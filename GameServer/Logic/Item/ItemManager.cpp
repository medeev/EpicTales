

#include "Pch.h"
#include "ItemManager.h"

#include <Data/Info/ItemInfo.h>

#include "Actor/ActorFactory.h"
#include "OrmSub/Item.h"
#include "Room/World.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief		생성자
////////////////////////////////////////////////////////////////////////////////////////////////////
ItemManager::ItemManager(Player& player) : _player(player)
{
	for (int32_t i = 0; i < (int32_t)EInventoryType::Max; ++i)
	{
		_bags[i] = std::make_shared<Bag>(player, (EInventoryType)i);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief		소멸자
////////////////////////////////////////////////////////////////////////////////////////////////////
ItemManager::~ItemManager()
{
	_bags.fill(nullptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 추가한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::insertItem(ItemPtr item)
{
	ENSURE(item, return false);

	auto ret = _items.insert(std::make_pair(item->getId(), item));
	if (!ret.second)
	{
		WARN_LOG("itemid is duplcated. [ownerId:%llu, itemId:%llu]", item->getOwnerId(), item->getId());
		return false;
	}

	auto invenType = (int32_t)item->getInfo().getInventoryType();
	if (invenType >= _bags.size())
		return false;

	return _bags[invenType]->insertItem(item);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 찾는다.
////////////////////////////////////////////////////////////////////////////////////////////////////
const ItemPtr ItemManager::findItem(PktObjId id) const
{
	auto iter = _items.find(id);
	if (iter == _items.end())
		return nullptr;

	return iter->second;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 찾는다.
////////////////////////////////////////////////////////////////////////////////////////////////////
ItemPtr ItemManager::findItem(PktObjId id)
{
	return std::const_pointer_cast<Item>(static_cast<const ItemManager&>(*this).findItem(id));
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  아이템을 찾는다.
////////////////////////////////////////////////////////////////////////////////////////////////////
const ItemPtr ItemManager::findItem(const ItemInfo& info) const
{
	auto invenType = (int32_t)info.getInventoryType();
	if (invenType >= _bags.size())
		return nullptr;

	return _bags[invenType]->findItem(info);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  아이템을 찾는다.
////////////////////////////////////////////////////////////////////////////////////////////////////
ItemPtr ItemManager::findItem(const ItemInfo& info)
{
	return std::const_pointer_cast<Item>(static_cast<const ItemManager&>(*this).findItem(info));
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  아이템을 찾는다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::findItems(const ItemInfo& info, std::vector<ItemPtr>& outItems) const
{
	auto invenType = (int32_t)info.getInventoryType();
	if (invenType >= _bags.size())
		return false;

	return _bags[invenType]->findItems(info, outItems);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 삭제한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void ItemManager::deleteItem(PktObjId id)
{
	auto item = findItem(id);
	if (!item)
		return;

	_items.erase(id);

	auto invenType = (int32_t)item->getInfo().getInventoryType();
	if (invenType < _bags.size())
		_bags[invenType]->deleteItem(id);
}



////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief	DB객체로 초기화한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::_initByList(const std::list<std::shared_ptr<DBOrm::Item>>& ormItems)
{
	for (auto itemOrm : ormItems)
	{
		auto infoId = itemOrm->getInfoId();
		ItemInfoPtr itemInfo(infoId);
		if (!itemInfo)
		{
			WARN_LOG("none iteminfoId exist. [itemId: %llu, ownerId:%llu, itemInfoId: %u",
				itemOrm->getId(), itemOrm->getOwnerId(), infoId);

			continue;
		}

		auto item = std::make_shared<Item>(*itemInfo);
		itemOrm->copyMember(*item);

		insertItem(item);
	}
		
	return true;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 DB에 추가한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::insertItem(
	CacheTx& cacheTx, 
	const ItemInfo& itemInfo,
	int32_t count,
	PktItemChangeData* pktItemChangeData) const
{
	int32_t invenType = (int32_t)(itemInfo.getInventoryType());
	if (invenType >= _bags.size())
		return false;

	return _bags[invenType]->insertItem(cacheTx, itemInfo, count, pktItemChangeData);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 DB에서 삭제한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::deleteItem(
	CacheTx& cacheTx, 
	const ItemInfo& itemInfo,
	int32_t count,
	PktItemChangeData* pktItemChangeData) const
{
	int32_t invenType = (int32_t)(itemInfo.getInventoryType());
	if (invenType >= _bags.size())
		return false;

	return _bags[invenType]->deleteItem(cacheTx, itemInfo, count, pktItemChangeData);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 DB에서 삭제한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::deleteItem(
	CacheTx& cacheTx, 
	PktObjId itemId, 
	int32_t count,
	PktItemChangeData* pktItemChangeData) const
{
	auto item = findItem(itemId);
	if (!item)
		return false;

	return deleteItem(cacheTx, item, count);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  아이템을 DB에서 삭제한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ItemManager::deleteItem(
	CacheTx& cacheTx, 
	ItemPtr item, 
	int32_t count,
	PktItemChangeData* pktItemChangeData) const
{
	ENSURE(item, return false);

	int32_t invenType = (int32_t)(item->getInfo().getInventoryType());
	if (invenType >= _bags.size())
		return false;

	return _bags[invenType]->deleteItem(cacheTx, item, count, pktItemChangeData);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  인벤토리아이템을 내보낸다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void ItemManager::exportTo(
	EInventoryType invenType, std::vector<PktItem>& pktItems) const
{
	if ((int32_t)invenType < _bags.size())
	{
		_bags[(int32_t)invenType]->exportTo(pktItems);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ brief  모든 인벤토리 아이템을 내보낸다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void ItemManager::exportTo(std::vector<PktItem>& pktItems) const
{
	for (const auto& bag : _bags)
	{
		bag->exportTo(pktItems);
	}
}

