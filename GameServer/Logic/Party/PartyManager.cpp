


#include "Pch.h"
#include "PartyManager.h"

#include <Core/Thread/ThreadChecker.h>

#include "Party.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief		생성자
////////////////////////////////////////////////////////////////////////////////////////////////////
PartyManager::PartyManager()
	:
	IThread("Party"),
	_taskManager("PartyThread", *this)
{

}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief	소멸자
////////////////////////////////////////////////////////////////////////////////////////////////////
PartyManager::~PartyManager()
{

}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief		순회한다
////////////////////////////////////////////////////////////////////////////////////////////////////
void PartyManager::foreachParty(const Callback& callback)
{
	if (!Core::ThreadChecker::Check(getId(), "PartyManager foreach"))
		return;

	for (auto& it : _parties)
		callback(it.second);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief		해당 스레드에서 작업을 실행한다
////////////////////////////////////////////////////////////////////////////////////////////////////
void PartyManager::runTask(const Core::TaskCaller& taskCaller, const Core::TaskManager::Task& task)
{
	_taskManager.runTask(taskCaller, task);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief		스레드 코드를 실행한다
////////////////////////////////////////////////////////////////////////////////////////////////////
void PartyManager::onRun()
{
	auto oldSec = Core::Time::GetCurTimeMSec();
	srand((uint32_t)oldSec);

	while (_running)
	{
		auto mSec = Core::Time::GetCurTimeMSec();
		int32_t timeDiff = (int32_t)(mSec - oldSec);
		oldSec = mSec;

		_taskManager.update(mSec);

		for (auto it = _parties.begin(); it != _parties.end(); )
		{
			auto& party = it->second;

			party->setDeltaMSec(timeDiff);
			party->setTime(mSec);
			party->update();

			if (party->isRemoveable())
			{
				it = _parties.erase(it);
			}
			else
			{
				++it;
			}
		}

		for (auto it = _matchings.begin(); it != _matchings.end(); )
		{
			auto& matching = it->second;

			matching->setDeltaMSec(timeDiff);
			matching->setTime(mSec);
			matching->update();

			if (matching->isRemoveable())
			{
				it = _matchings.erase(it);
			}
			else
			{
				++it;
			}
		}

		IThread::Sleep(1);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief		옥션을 추가한다
////////////////////////////////////////////////////////////////////////////////////////////////////
void PartyManager::addParty(PartyPtr party)
{
	if (!party)
		return;

	runTask(
		Caller,
		[this, party]()
		{
			_parties[party->getId()] = party;
		});
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  옥션를 가져온다.
////////////////////////////////////////////////////////////////////////////////////////////////////
PartyPtr PartyManager::getParty(uint64_t id)
{
	return std::dynamic_pointer_cast<Party>(((const PartyManager*)this)->getParty(id));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  옥션를 가져온다.
////////////////////////////////////////////////////////////////////////////////////////////////////
const PartyPtr PartyManager::getParty(uint64_t id) const
{
	if (!Core::ThreadChecker::Check(getId(), "getParty"))
		return nullptr;

	auto iter = _parties.find(id);
	if (iter == _parties.end())
		return nullptr;

	return iter->second;
}
